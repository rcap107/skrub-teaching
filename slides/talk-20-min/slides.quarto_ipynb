{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Skrub\"\n",
        "title-block-banner: true\n",
        "date: 2025-10-01\n",
        "subtitle: \"Machine learning with dataframes\"\n",
        "author: \"Riccardo Cappuzzo, Guillaume LemaÃ®tre, JÃ©rÃ´me DockÃ¨s\"\n",
        "institute: \"Inria P16, probabl.\"\n",
        "format: \n",
        "    revealjs:\n",
        "        slide-number: c/t\n",
        "        show-slide-number: all\n",
        "        preview-links: auto\n",
        "        embed-resources: false\n",
        "        transition: slide\n",
        "        theme: simple\n",
        "        logo: images/skrub.svg\n",
        "        css: style.css\n",
        "        footer: \"https://skrub-data.org/skrub-materials/\"\n",
        "incremental: false\n",
        "params: \n",
        "    version: \"base\"\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "## `whoami`  {visibility=\"hidden\"}\n",
        "\n",
        "::: {.incremental}\n",
        "\n",
        "- I am a research engineer at Inria as part of the P16 project, and I am the lead developer of skrub ![](images/inria.png){width=250}\n",
        "\n",
        "- I'm Italian, but I don't drink coffee, wine, and I like pizza with fries ![](images/raora.png){width=50}\n",
        "\n",
        "- I did my PhD in CÃ´te d'Azur, and I moved away because it was too sunny and \n",
        "I don't like the sea ![](images/nice.jpg){width=250}\n",
        "\n",
        ":::\n",
        "\n",
        "# Boost your productivity with skrub! {auto-animate=\"true\"}\n",
        "\n",
        "Skrub simplifies many tedious data preparation operations\n",
        "\n",
        "\n",
        "## A teaser for later... {auto-animate=\"true\"}\n",
        "\n",
        "Inspect all the steps of your pipeline: \n",
        "<a href=\"dataop_report/index.html\" target=\"_blank\">Execution report</a>\n",
        "\n",
        "## A teaser for later... {auto-animate=\"true\"} \n",
        "Explore your hyperparameter search space"
      ],
      "id": "f56edf7f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from plotly.io import read_json\n",
        "\n",
        "fig = read_json(\"parallel_coordinates_hgbr.json\")\n",
        "fig.update_layout(margin=dict(l=200))"
      ],
      "id": "564f8143",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Skrub compatibility\n",
        "- Skrub is fully compatible with pandas and polars\n",
        "- Skrub transformers are fully compatible with scikit-learn\n",
        "\n",
        "## An example pipeline\n",
        "1. Gather some data\n",
        "2. Explore the data\n",
        "3. Preprocess the data \n",
        "4. Perform feature engineering \n",
        "5. Build a scikit-learn pipeline\n",
        "6. ???\n",
        "7. Profit?  \n",
        "\n",
        "##  \n",
        "![](images/here-we-go-again.png)\n",
        "\n",
        "## Exploring the data with `skrub` {.smaller auto-animate=\"true\"}\n",
        "\n",
        "```{.python}\n",
        "from skrub import TableReport\n",
        "TableReport(employee_salaries)\n",
        "```\n",
        "[TableReport Preview](https://skrub-data.org/skrub-reports/examples/employee_salaries.html){preview-link=\"true\"}\n",
        "\n",
        "\n",
        "::: {.fragment}\n",
        "::: {.nonincremental}\n",
        "Main features:\n",
        "\n",
        "- Obtain high-level statistics about the data\n",
        "- Explore the distribution of values and find outliers\n",
        "- Discover highly correlated columns \n",
        "- Export and share the report as an `html` file\n",
        ":::\n",
        ":::\n",
        "\n",
        "::: {.fragment}\n",
        "<a href=\"https://skrub-data.org/skrub-reports/examples/\" target=\"_blank\">More examples</a>\n",
        "\n",
        ":::\n",
        "\n",
        "## Data cleaning with pandas/polars: setup {.smaller auto-animate=\"true\"}\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "### Pandas"
      ],
      "id": "b8cb7a4f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "\n",
        "data = {\n",
        "    \"Int\": [2, 3, 2],  # Multiple unique values\n",
        "    \"Const str\": [\"x\", \"x\", \"x\"],  # Single unique value\n",
        "    \"Str\": [\"foo\", \"bar\", \"baz\"],  # Multiple unique values\n",
        "    \"All nan\": [np.nan, np.nan, np.nan],  # All missing values\n",
        "    \"All empty\": [\"\", \"\", \"\"],  # All empty strings\n",
        "    \"Date\": [\"01 Jan 2023\", \"02 Jan 2023\", \"03 Jan 2023\"],\n",
        "}\n",
        "\n",
        "df_pd = pd.DataFrame(data)\n",
        "display(df_pd)"
      ],
      "id": "e2f0b32c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Polars"
      ],
      "id": "d7aace85"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import polars as pl\n",
        "import numpy as np\n",
        "data = {\n",
        "    \"Int\": [2, 3, 2],  # Multiple unique values\n",
        "    \"Const str\": [\"x\", \"x\", \"x\"],  # Single unique value\n",
        "    \"Str\": [\"foo\", \"bar\", \"baz\"],  # Multiple unique values\n",
        "    \"All nan\": [np.nan, np.nan, np.nan],  # All missing values\n",
        "    \"All empty\": [\"\", \"\", \"\"],  # All empty strings\n",
        "    \"Date\": [\"01 Jan 2023\", \"02 Jan 2023\", \"03 Jan 2023\"],\n",
        "}\n",
        "\n",
        "df_pl = pl.DataFrame(data)\n",
        "display(df_pl)"
      ],
      "id": "4636c939",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "## Nulls, datetimes, constant columns with pandas/polars {.smaller auto-animate=\"true\"}\n",
        "\n",
        ":::{.panel-tabset}\n",
        "### Pandas"
      ],
      "id": "7e34b441"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "# Parse the datetime strings with a specific format\n",
        "df_pd['Date'] = pd.to_datetime(df_pd['Date'], format='%d %b %Y')\n",
        "\n",
        "# Drop columns with only a single unique value\n",
        "df_pd_cleaned = df_pd.loc[:, df_pd.nunique(dropna=True) > 1]\n",
        "\n",
        "# Function to drop columns with only missing values or empty strings\n",
        "def drop_empty_columns(df):\n",
        "    # Drop columns with only missing values\n",
        "    df_cleaned = df.dropna(axis=1, how='all')\n",
        "    # Drop columns with only empty strings\n",
        "    empty_string_cols = df_cleaned.columns[df_cleaned.eq('').all()]\n",
        "    df_cleaned = df_cleaned.drop(columns=empty_string_cols)\n",
        "    return df_cleaned\n",
        "\n",
        "# Apply the function to the DataFrame\n",
        "df_pd_cleaned = drop_empty_columns(df_pd_cleaned)"
      ],
      "id": "b1e78bf4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Polars"
      ],
      "id": "05f3b9e8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true \n",
        "# Parse the datetime strings with a specific format\n",
        "df_pl = df_pl.with_columns([\n",
        "    pl.col(\"Date\").str.strptime(pl.Date, \"%d %b %Y\", strict=False).alias(\"Date\")\n",
        "])\n",
        "\n",
        "# Drop columns with only a single unique value\n",
        "df_pl_cleaned = df_pl.select([\n",
        "    col for col in df_pl.columns if df_pl[col].n_unique() > 1\n",
        "])\n",
        "\n",
        "# Import selectors for dtype selection\n",
        "import polars.selectors as cs\n",
        "\n",
        "# Drop columns with only missing values or only empty strings\n",
        "def drop_empty_columns(df):\n",
        "    all_nan = df.select(\n",
        "        [\n",
        "            col for col in df.select(cs.numeric()).columns if \n",
        "            df [col].is_nan().all()\n",
        "        ]\n",
        "    ).columns\n",
        "    \n",
        "    all_empty = df.select(\n",
        "        [\n",
        "            col for col in df.select(cs.string()).columns if \n",
        "            (df[col].str.strip_chars().str.len_chars()==0).all()\n",
        "        ]\n",
        "    ).columns\n",
        "\n",
        "    to_drop = all_nan + all_empty\n",
        "\n",
        "    return df.drop(to_drop)\n",
        "\n",
        "df_pl_cleaned = drop_empty_columns(df_pl_cleaned)"
      ],
      "id": "a5cacdf2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Data cleaning with `skrub.Cleaner` {.smaller auto-animate=\"true\"}\n",
        "\n",
        ":::{.panel-tabset}\n",
        "### Pandas"
      ],
      "id": "ce0889eb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from skrub import Cleaner\n",
        "cleaner = Cleaner(drop_if_constant=True, datetime_format='%d %b %Y')\n",
        "df_cleaned = cleaner.fit_transform(df_pd)\n",
        "display(df_cleaned)"
      ],
      "id": "692a058d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Polars"
      ],
      "id": "8f2510d1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from skrub import Cleaner\n",
        "cleaner = Cleaner(drop_if_constant=True, datetime_format='%d %b %Y')\n",
        "df_cleaned = cleaner.fit_transform(df_pl)\n",
        "display(df_cleaned)"
      ],
      "id": "248715ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## Encoding datetime features with `skrub.DatetimeEncoder` {auto-animate=\"true\" visibility=\"uncounted\" .smaller}"
      ],
      "id": "02dbfe9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import polars as pl\n",
        "data = {\n",
        "    'date': ['2023-01-01 12:34:56', '2023-02-15 08:45:23', '2023-03-20 18:12:45'],\n",
        "    'value': [10, 20, 30]\n",
        "}\n",
        "df = pl.DataFrame(data)"
      ],
      "id": "f8656071",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from skrub import DatetimeEncoder, ToDatetime\n",
        "\n",
        "X_date = ToDatetime().fit_transform(df[\"date\"])\n",
        "de = DatetimeEncoder(resolution=\"second\")\n",
        "# de = DatetimeEncoder(periodic_encoding=\"spline\")\n",
        "X_enc = de.fit_transform(X_date)\n",
        "print(X_enc)"
      ],
      "id": "22c39361",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Encoding numerical features with `skrub.SquashingScaler`"
      ],
      "id": "962f0033"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-align: center\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "np.random.seed(0)  # for reproducibility\n",
        "\n",
        "values = np.random.rand(100, 1)\n",
        "n_outliers = 15\n",
        "outlier_indices = np.random.choice(values.shape[0], size=n_outliers, replace=False)\n",
        "values[outlier_indices] = np.random.rand(n_outliers, 1) * 100 - 50\n",
        "\n",
        "x = np.arange(values.shape[0])\n",
        "fig, axs = plt.subplots(1, layout=\"constrained\", figsize=(6, 4))\n",
        "\n",
        "axs.plot(x,values)\n",
        "_ = axs.set(\n",
        "    title=\"Feature with outliers\",\n",
        "    ylabel=\"value\",\n",
        "    xlabel=\"Sample ID\"\n",
        "    )\n",
        "axs.axhspan(-2, 2, color=\"gray\", alpha=0.15)\n",
        "\n",
        "x_data, y_data = [30, 2]\n",
        "desc = \"Data is mostly\\nin [-2, 2]\"\n",
        "axs.annotate(\n",
        "    desc,\n",
        "    xy=(x_data, y_data),\n",
        "    xytext=(0.15, 0.8),\n",
        "    textcoords=\"axes fraction\",\n",
        "    arrowprops=dict(arrowstyle=\"->\", color=\"red\"),\n",
        "\n",
        ")\n",
        "\n",
        "x_outlier, y_outlier = np.argmax(values), np.max(values)\n",
        "desc = \"There are large\\noutliers throughout.\"\n",
        "_ = axs.annotate(\n",
        "    desc,\n",
        "    xy=(x_outlier, y_outlier),\n",
        "    xytext=(0.6, 0.85),\n",
        "    textcoords=\"axes fraction\",\n",
        "    arrowprops=dict(arrowstyle=\"->\", color=\"red\"),\n",
        "\n",
        ")"
      ],
      "id": "0e361495",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.notes}\n",
        "Skrub wants to solve ML problems based partly on solid engineering and partly on\n",
        "statistical notions. The SquashingScaler is based on the second part, and is taken\n",
        "from a recent paper that evaluates different techniques for improving the performance\n",
        "of NNs. \n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "## Encoding numerical features with `skrub.SquashingScaler`"
      ],
      "id": "8a656269"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| fig-align: center\n",
        "from sklearn.preprocessing import QuantileTransformer, RobustScaler, StandardScaler\n",
        "from skrub import SquashingScaler\n",
        "\n",
        "squash_scaler = SquashingScaler()\n",
        "squash_scaled = squash_scaler.fit_transform(values)\n",
        "\n",
        "robust_scaler = RobustScaler()\n",
        "robust_scaled = robust_scaler.fit_transform(values)\n",
        "\n",
        "standard_scaler = StandardScaler()\n",
        "standard_scaled = standard_scaler.fit_transform(values)\n",
        "\n",
        "quantile_transformer = QuantileTransformer(n_quantiles=100)\n",
        "quantile_scaled = quantile_transformer.fit_transform(values)\n",
        "# %%\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "x = np.arange(values.shape[0])\n",
        "fig, axs = plt.subplots(1, 2, layout=\"constrained\", figsize=(8, 5))\n",
        "\n",
        "ax = axs[0]\n",
        "ax.plot(x, sorted(values), label=\"Original Values\", linewidth=2.5)\n",
        "ax.plot(x, sorted(squash_scaled), label=\"SquashingScaler\")\n",
        "ax.plot(x, sorted(robust_scaled), label=\"RobustScaler\", linestyle=\"--\")\n",
        "ax.plot(x, sorted(standard_scaled), label=\"StandardScaler\")\n",
        "ax.plot(x, sorted(quantile_scaled), label=\"QuantileTransformer\")\n",
        "\n",
        "# Add a horizontal band in [-4, +4]\n",
        "ax.axhspan(-4, 4, color=\"gray\", alpha=0.15)\n",
        "ax.set(title=\"Original data\", xlim=[0, values.shape[0]], xlabel=\"Percentile\")\n",
        "ax.legend()\n",
        "\n",
        "ax = axs[1]\n",
        "ax.plot(x, sorted(values), label=\"Original Values\", linewidth=2.5)\n",
        "ax.plot(x, sorted(squash_scaled), label=\"SquashingScaler\")\n",
        "ax.plot(x, sorted(robust_scaled), label=\"RobustScaler\", linestyle=\"--\")\n",
        "ax.plot(x, sorted(standard_scaled), label=\"StandardScaler\")\n",
        "ax.plot(x, sorted(quantile_scaled), label=\"QuantileTransformer\")\n",
        "\n",
        "ax.set(ylim=[-4, 4])\n",
        "ax.set(title=\"In range [-4, 4]\", xlim=[0, values.shape[0]], xlabel=\"Percentile\")\n",
        "\n",
        "# Highlight the bounds of the SquashingScaler\n",
        "ax.axhline(y=3, alpha=0.2)\n",
        "ax.axhline(y=-3, alpha=0.2)\n",
        "\n",
        "fig.suptitle(\n",
        "    \"Comparison of different scalers on sorted data with outliers\", fontsize=20\n",
        ")\n",
        "fig.supylabel(\"Value\")\n",
        "\n",
        "desc = \"The RobustScaler is\\naffected by outliers\"\n",
        "axs[0].annotate(\n",
        "    desc,\n",
        "    xy=(0, -70),\n",
        "    xytext=(0.4, 0.2),\n",
        "    textcoords=\"axes fraction\",\n",
        "    arrowprops=dict(arrowstyle=\"->\", color=\"red\"),\n",
        ")\n",
        "\n",
        "desc = \"The SquashingScaler is\\nclipped to a finite value\"\n",
        "_ = axs[1].annotate(\n",
        "    desc,\n",
        "    xy=(0, -3),\n",
        "    xytext=(0.4, 0.2),\n",
        "    textcoords=\"axes fraction\",\n",
        "    arrowprops=dict(arrowstyle=\"->\", color=\"red\"),\n",
        ")"
      ],
      "id": "c556affc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Encoding categorical (string/text) features\n",
        "Categorical features have a \"**cardinality**\": the number of unique values\n",
        "\n",
        "::: {.incremental}\n",
        "\n",
        "- Low cardinality: `OneHotEncoder`\n",
        "- High cardinality (>40 unique values): `skrub.StringEncoder`\n",
        "- Text: `skrub.TextEncoder` and pretrained models from HuggingFace Hub\n",
        "\n",
        ":::\n",
        "\n",
        "## Encoding _all the features_: `TableVectorizer` { auto-animate=\"true\"}\n"
      ],
      "id": "7824ea8c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from skrub import TableVectorizer\n",
        "\n",
        "table_vec = TableVectorizer()\n",
        "df_encoded = table_vec.fit_transform(df)"
      ],
      "id": "aa306dc4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.fragment}\n",
        "- Apply the `Cleaner` to all columns\n",
        "- Split columns by dtype and # of unique values\n",
        "- Encode each column separately\n",
        ":::\n",
        "\n",
        "\n",
        "## Encoding _all the features_: `TableVectorizer` {.smaller auto-animate=\"true\"}\n",
        "\n",
        "![](images/skrub-table-vectorizer.png)\n",
        "\n",
        "\n",
        "## Build a predictive pipeline {auto-animate=\"true\"}\n",
        "```{.python}\n",
        "from sklearn.linear_model import Ridge\n",
        "model = Ridge()\n",
        "```\n",
        "## Build a predictive pipeline {auto-animate=\"true\" visibility=\"uncounted\"}\n",
        "```{.python}\n",
        "from sklearn.linear_model import Ridge\n",
        "from sklearn.pipeline import make_pipeline\n",
        "from sklearn.preprocessing import StandardScaler, OneHotEncoder\n",
        "from sklearn.impute import SimpleImputer\n",
        "from sklearn.compose import make_column_selector as selector\n",
        "from sklearn.compose import make_column_transformer\n",
        "\n",
        "categorical_columns = selector(dtype_include=object)(employees)\n",
        "numerical_columns = selector(dtype_exclude=object)(employees)\n",
        "\n",
        "ct = make_column_transformer(\n",
        "      (StandardScaler(),\n",
        "       numerical_columns),\n",
        "      (OneHotEncoder(handle_unknown=\"ignore\"),\n",
        "       categorical_columns))\n",
        "\n",
        "model = make_pipeline(ct, SimpleImputer(), Ridge())\n",
        "```\n",
        "## Build a predictive pipeline with `tabular_pipeline` {auto-animate=\"true\" .smaller}\n",
        "```{.python}\n",
        "import skrub\n",
        "from sklearn.linear_model import Ridge\n",
        "model = skrub.tabular_pipeline(Ridge())\n",
        "```\n",
        "\n",
        "![](images/skrub-tabular-pipeline-linear-model.png){fig-align=\"center\"}\n",
        "\n",
        "## \n",
        "![](images/drakeno.png){fig-align=\"center\"}\n",
        "\n",
        "## We now have a pipeline! {.smaller}\n",
        "\n",
        "1. Gather some data\n",
        "2. Explore the data\n",
        "    - `TableReport`\n",
        "3. Pre-process the data \n",
        "    - `Cleaner`, `ToDatetime` ... \n",
        "4. Perform feature engineering\n",
        "    - `TableVectorizer`, `SquashingScaler`, `TextEncoder`, `StringEncoder `...\n",
        "5. Build a scikit-learn pipeline\n",
        "    - `tabular_pipeline`\n",
        "6. ???\n",
        "7. Profit ðŸ“ˆ \n",
        "\n",
        "\n",
        "# What if this is not enough?? \n",
        "\n",
        "## What if... {.smaller}\n",
        "\n",
        "::: {.incremental}\n",
        "\n",
        "- Your data is spread over multiple tables? \n",
        "- You want to avoid data leakage? \n",
        "- You want to tune more than just the hyperparameters of your model? \n",
        "- You want to guarantee that your pipeline is replayed exactly on new data? \n",
        "\n",
        ":::\n",
        "\n",
        "::: {.fragment}\n",
        "When a normal pipeline is not enough...\n",
        "::: \n",
        "\n",
        "::: {.fragment }\n",
        "... the `skrub` DataOps come to the rescue ðŸš’\n",
        ":::\n",
        "\n",
        "\n",
        "## DataOps...\n",
        "\n",
        "::: {.incremental}\n",
        "- Extend the `scikit-learn` machinery to complex multi-table operations, and take care of data leakage\n",
        "- Track all operations with a computational graph (a *Data Ops plan*)\n",
        "- Are transparent and give direct access to the underlying object\n",
        "- Allow tuning any operation in the Data Ops plan\n",
        "- Guarantee that all operations are reproducible\n",
        "- Can be persisted and shared easily \n",
        ":::\n",
        "\n",
        "## How do DataOps work, though?  {.smaller}\n",
        "DataOps **wrap** around *user operations*, where user operations are:\n",
        "\n",
        "- any dataframe operation (e.g., merge, group by, aggregate etc.)\n",
        "- scikit-learn estimators (a Random Forest, RidgeCV etc.)\n",
        "- custom user code (load data from a path, fetch from an URL etc.)\n",
        "\n",
        "::: {.fragment}\n",
        "\n",
        "::: {.callout-important}\n",
        "DataOps _record_ user operations, so that they can later be _replayed_ in the same\n",
        "order and with the same arguments on unseen data. \n",
        ":::\n",
        "::: \n",
        "\n",
        "## Starting with the `DataOps` {auto-animate=\"true\"} \n"
      ],
      "id": "b7cbdc7c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import skrub\n",
        "data = skrub.datasets.fetch_credit_fraud()\n",
        "\n",
        "baskets = skrub.var(\"baskets\", data.baskets)\n",
        "products = skrub.var(\"products\", data.products) # add a new variable\n",
        "\n",
        "X = baskets[[\"ID\"]].skb.mark_as_X()\n",
        "y = baskets[\"fraud_flag\"].skb.mark_as_y()"
      ],
      "id": "16c25c79",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- `baskets` and `products` represent inputs to the pipeline.\n",
        "- Skrub tracks `X` and `y` so that training and test splits are never mixed. \n",
        "\n",
        "## Applying a transformer {auto-animate=\"true\"}"
      ],
      "id": "7f79982c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "from skrub import selectors as s\n",
        "\n",
        "vectorizer = skrub.TableVectorizer(\n",
        "    high_cardinality=skrub.StringEncoder()\n",
        ")\n",
        "vectorized_products = products.skb.apply(\n",
        "    vectorizer, cols=s.all() - \"basket_ID\"\n",
        ")"
      ],
      "id": "1572a49d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##  Executing dataframe operations {auto-animate=\"true\"}"
      ],
      "id": "de03be64"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "aggregated_products = vectorized_products.groupby(\n",
        "    \"basket_ID\"\n",
        ").agg(\"mean\").reset_index()\n",
        "\n",
        "features = X.merge(\n",
        "    aggregated_products, left_on=\"ID\", right_on=\"basket_ID\"\n",
        ")\n",
        "features = features.drop(columns=[\"ID\", \"basket_ID\"])"
      ],
      "id": "e128ab5e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##  Applying a ML model {auto-animate=\"true\"}"
      ],
      "id": "358b8cbf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from sklearn.ensemble import ExtraTreesClassifier  \n",
        "predictions = features.skb.apply(\n",
        "    ExtraTreesClassifier(n_jobs=-1), y=y\n",
        ")"
      ],
      "id": "f3674528",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Inspecting the Data Ops plan\n",
        "```{.python}\n",
        "predictions.skb.full_report()\n",
        "```\n",
        "<br/>\n",
        "\n",
        "<a href=\"dataop_report/index.html\" target=\"_blank\">Execution report</a>\n",
        "\n",
        "Each node:\n",
        "\n",
        "- Shows a preview of the data resulting from the operation\n",
        "- Reports the location in the code where the code is defined\n",
        "- Shows the run time of the node \n",
        "\n",
        "## Exporting the plan in a `learner` {.smaller}\n",
        "The **Learner** is a stand-alone object that works like\n",
        "a scikit-learn estimator that takes a dictionary as input rather\n",
        "than just `X` and `y`. \n",
        "\n",
        "\n",
        "::: {.fragment}\n"
      ],
      "id": "548adb25"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "learner = predictions.skb.make_learner(fitted=True)"
      ],
      "id": "5a5b52d6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "::: {.fragment}\n",
        "Then, the `learner` can be pickled ...\n"
      ],
      "id": "b5600cd4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pickle \n",
        "\n",
        "learner_bytes = pickle.dumps(learner)"
      ],
      "id": "9ac141da",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{.python}\n",
        "import pickle\n",
        "\n",
        "with open(\"learner.bin\", \"wb\") as fp:\n",
        "    pickle.dump(learner, fp)\n",
        "```"
      ],
      "id": "f6c438b7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "loaded_learner = pickle.loads(learner_bytes)"
      ],
      "id": "2c17f120",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.fragment}\n",
        "... loaded and applied to new data:\n",
        "\n",
        "```{.python}\n",
        "with open(\"learner.bin\", \"rb\") as fp:\n",
        "    loaded_learner = pickle.load(fp)\n",
        "data = skrub.datasets.fetch_credit_fraud(split=\"test\")\n",
        "new_baskets = data.baskets\n",
        "new_products = data.products\n",
        "loaded_learner.predict({\"baskets\": new_baskets, \"products\": new_products})\n",
        "```"
      ],
      "id": "ab9ea15d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "data = skrub.datasets.fetch_credit_fraud(split=\"test\")\n",
        "new_baskets = data.baskets\n",
        "new_products = data.products\n",
        "loaded_learner.predict(\n",
        "    {\"baskets\": new_baskets, \"products\": new_products}\n",
        ")"
      ],
      "id": "513ddef8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "## Hyperparameter tuning in a Data Ops plan \n",
        "Skrub implements four `choose_*` functions:\n",
        "\n",
        "- `choose_from`: select from the given list of options\n",
        "- `choose_int`: select an integer within a range\n",
        "- `choose_float`: select a float within a range\n",
        "- `choose_bool`: select a bool \n",
        "- `optional`: chooses whether to execute the given operation\n",
        "\n",
        "\n",
        "## Tuning in `scikit-learn` can be complex {.smaller auto-animate=\"true\"}\n",
        "\n",
        "```{.python}\n",
        "pipe = Pipeline([(\"dim_reduction\", PCA()), (\"regressor\", Ridge())])\n",
        "grid = [\n",
        "    {\n",
        "        \"dim_reduction\": [PCA()],\n",
        "        \"dim_reduction__n_components\": [10, 20, 30],\n",
        "        \"regressor\": [Ridge()],\n",
        "        \"regressor__alpha\": loguniform(0.1, 10.0),\n",
        "    },\n",
        "    {\n",
        "        \"dim_reduction\": [SelectKBest()],\n",
        "        \"dim_reduction__k\": [10, 20, 30],\n",
        "        \"regressor\": [Ridge()],\n",
        "        \"regressor__alpha\": loguniform(0.1, 10.0),\n",
        "    },\n",
        "    {\n",
        "        \"dim_reduction\": [PCA()],\n",
        "        \"dim_reduction__n_components\": [10, 20, 30],\n",
        "        \"regressor\": [RandomForestClassifier()],\n",
        "        \"regressor__n_estimators\": loguniform(20, 200),\n",
        "    },\n",
        "    {\n",
        "        \"dim_reduction\": [SelectKBest()],\n",
        "        \"dim_reduction__k\": [10, 20, 30],\n",
        "        \"regressor\": [RandomForestClassifier()],\n",
        "        \"regressor__n_estimators\": loguniform(20, 200),\n",
        "    },\n",
        "]\n",
        "```\n",
        "## Tuning with Data Ops is simple! {.smaller} \n",
        "\n",
        "```python \n",
        "dim_reduction = X.skb.apply(\n",
        "    skrub.choose_from(\n",
        "        {\n",
        "            \"PCA\": PCA(n_components=skrub.choose_int(10, 30)),\n",
        "            \"SelectKBest\": SelectKBest(k=skrub.choose_int(10, 30))\n",
        "        }, name=\"dim_reduction\"\n",
        "    )\n",
        ")\n",
        "regressor = dim_reduction.skb.apply(\n",
        "    skrub.choose_from(\n",
        "        {\n",
        "            \"Ridge\": Ridge(alpha=skrub.choose_float(0.1, 10.0, log=True)),\n",
        "            \"RandomForest\": RandomForestClassifier(\n",
        "                n_estimators=skrub.choose_int(20, 200, log=True)\n",
        "            )\n",
        "        }, name=\"regressor\"\n",
        "    )\n",
        ")\n",
        "```\n",
        "\n",
        "## Run hyperparameter search\n",
        "```{.python}\n",
        "# fit the search \n",
        "search = regressor.skb.make_randomized_search(\n",
        "    scoring=\"roc_auc\", fitted=True, cv=5\n",
        ")\n",
        "\n",
        "# save the best learner\n",
        "best_learner = search.best_learner_\n",
        "```\n",
        "\n",
        "## Tuning with Data Ops is not limited to estimators\n",
        "::: {.panel-tabset}\n",
        "### Pandas"
      ],
      "id": "dccddc4e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "import skrub"
      ],
      "id": "94be021d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "df = pd.DataFrame(\n",
        "    {\"subject\": [\"math\", \"math\", \"art\", \"history\"],\n",
        "    \"grade\": [10, 8, 4, 6]}\n",
        ")\n",
        "\n",
        "df_do = skrub.var(\"grades\", df)\n",
        "agg_grades = df_do.groupby(\"subject\").agg(\n",
        "    skrub.choose_from([\"count\", \"mean\"])\n",
        ")\n",
        "agg_grades.skb.describe_param_grid()"
      ],
      "id": "e2fccbb7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Polars"
      ],
      "id": "a4a4e411"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import polars as pl\n",
        "import skrub"
      ],
      "id": "5ad2a92b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "df = pl.DataFrame(\n",
        "    {\"subject\": [\"math\", \"math\", \"art\", \"history\"], \"grade\": [10, 8, 4, 6]}\n",
        ")\n",
        "\n",
        "df_do = skrub.var(\"grades\", df)\n",
        "\n",
        "agg_grades = df_do.group_by(\"subject\").agg(\n",
        "    skrub.choose_from([\n",
        "        pl.mean(\"grade\"), pl.count(\"grade\")\n",
        "    ])\n",
        ")\n",
        "agg_grades.skb.describe_param_grid()"
      ],
      "id": "5a05536a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "## A parallel coordinate plot to explore hyperparameters{auto-animate=\"true\" .smaller} \n",
        "\n",
        "```{.python}\n",
        "search = pred.skb.get_randomized_search(fitted=True)\n",
        "search.plot_parallel_coord()\n",
        "```"
      ],
      "id": "beff87e4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from plotly.io import read_json\n",
        "\n",
        "fig = read_json(\"parallel_coordinates_hgbr.json\")\n",
        "fig.update_layout(margin=dict(l=200))"
      ],
      "id": "e7e42dea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## More information about the Data Ops \n",
        "- Skrub [example gallery](https://skrub-data.org/stable/auto_examples/data_ops/index.html)\n",
        "- Skrub [user guide](https://skrub-data.org/stable/documentation.html)\n",
        "- [Tutorial](https://github.com/skrub-data/EuroSciPy2025) on timeseries \n",
        "forecasting at Euroscipy 2025\n",
        "- [Kaggle notebook](https://www.kaggle.com/code/ryye107/titanic-challenge-with-the-skrub-data-ops) \n",
        "on the Titanic survival challenge\n",
        "\n",
        "\n",
        "# Wrapping up\n",
        "\n",
        "## {auto-animate=\"true\" } \n",
        "![](images/powerpuff_girls_1.png)\n",
        "\n",
        "## {auto-animate=\"true\" } \n",
        "![](images/powerpuff_girls_2.png)\n",
        "\n",
        "##  Getting involved {.smaller}\n",
        "::: {.nonincremental}\n",
        "Do you want to learn more? \n",
        "\n",
        "- [Skrub website](https://skrub-data.org/stable/) \n",
        "- [Skrub materials website](https://skrub-data.org/skrub-materials/index.html)\n",
        "- [Discord server](https://discord.gg/ABaPnm7fDC)\n",
        "\n",
        "Follow skrub on:\n",
        "\n",
        "- [Bluesky](https://bsky.app/profile/skrub-data.bsky.social)\n",
        "- [LinkedIn](https://www.linkedin.com/company/skrub-data/)\n",
        "\n",
        "Star skrub on GitHub, or contribute directly: \n",
        "\n",
        "- [GitHub repository](https://github.com/skrub-data/skrub/)\n",
        ":::\n",
        "\n",
        "## tl;dw: skrub \n",
        "::: {.nonincremental}\n",
        "- interactive data exploration: `TableReport`\n",
        "- automated pre-processing of pandas and polars dataframes: `Cleaner`\n",
        "- powerful feature engineering: `TableVectorizer`, `tabular_pipeline`\n",
        "- column- and dataframe-level operations: `ApplyToCols`, selectors\n",
        "- DataOps, plans, hyperparameter tuning, (almost) no leakage \n",
        ":::"
      ],
      "id": "ac93e1de"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/rcap/Library/Python/3.9/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}